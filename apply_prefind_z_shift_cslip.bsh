// load x y z shifts from prefind and apply to positions list
import org.micromanager.PositionList;
import org.micromanager.StagePosition;
import org.micromanager.MultiStagePosition;

import org.micromanager.PositionList;
import org.micromanager.internal.utils.MMException;
import java.lang.*;
import java.util.*;

path = "E:/nina/20230331_drug_plate3/cslip_find/23-04-03/17-29-50/";
csv_path = path + "coverslip_z.csv";

old_path =  "E:/nina/20230331_drug_plate3/main/23-04-01/01-09-37/live_cslip/run_7/";
old_csv_path = old_path + "coverslip_z.csv";

PositionList pl = mm.positions().getPositionList();
n_pos = pl.getNumberOfPositions();

xyStage = "XYStage";
zStage = "ZAxis";

// Double[] x_shift = new Double[n_pos];
// Double[] y_shift = new Double[n_pos];
// Double[] z_shift = new Double[n_pos];

Double[] z_cslip_new = new Double[n_pos];
Double[] z_cslip_old = new Double[n_pos];

int x_shift = 0;
int y_shift = 0;
int z_new = 0;

int max_diff = 1500;

BufferedReader br = new BufferedReader(new FileReader(csv_path));
String line = new String();

PositionList pl_new = new PositionList();
MultiStagePosition msp;
n = 0;
i = 0;
int[] failed = new int[n_pos]; 
double[] z_shifts = new double[n_pos];
double z_shift_sum = 0;

n = 0;
// while ((line = br.readLine()) != null) {
for (n=0; n<n_pos; n++){
	line = br.readLine();
	new_cslip_z = Double.parseDouble(line);
	z_cslip_new[n] = new_cslip_z;
	print("new " + new_cslip_z);
	print(n);
	// n++;
}

br.close();

BufferedReader old_br = new BufferedReader(new FileReader(old_csv_path));
String old_line = new String();

n = 0;
//while ((old_line = old_br.readLine()) != null) {
for (n=0; n<n_pos; n++){
	old_line = old_br.readLine();
	old_cslip_z = Double.parseDouble(old_line);
	z_cslip_old[n] = old_cslip_z;
	print("old " + old_cslip_z);
	// n++;
}

old_br.close();
n = 0;
for (n = 0; n < n_pos; n++){
	// get current pos
	print("i " + n);
	new_z = (int)z_cslip_new[n];
	old_z = (int)z_cslip_old[n];
	//print(values[0]);
	print(new_z + " " + old_z);

	z_shift = new_z - old_z;
	print(z_shift);

	if (Math.abs(z_shift) < max_diff){
		failed[n] = 0;
	} else{
		z_shift = 0;
		failed[n] = 1;
	}
	z_shift_sum += z_shift;
	z_shifts[n] = z_shift;

	print(" z shift: " + z_shift);
	
}
n = 0;
z_shift_mean = z_shift_sum/n_pos;
for (n=0; n<n_pos; n++){
	z_shift = 0;
	if (failed[n] == 1) {
		z_shift = z_shift_mean;
	} else {
		z_shift = z_shifts[n];
	}
	// get current pos
	mp = pl.getPosition(n);
	label = mp.getLabel();
	
	
	x_i = (int) Math.floor(mp.getX()); 
	y_i = (int) Math.floor(mp.getY());
	z_i = (int) Math.floor(mp.getZ()); 
	
	z_new = z_i + (int)z_shift;
		
	msp = new MultiStagePosition(xyStage, x_i, y_i, zStage, z_new);
	
	msp.setLabel(label);
	pl_new.addPosition(msp);
		
}

mm.positions().setPositionList(pl_new);