for(f = 124; f < n_pos; f++) {  // fields
	print("Field "+ f);
	found = false;
	mmc.setExposure(cslip_exp);  // reset exp for scatter
	full_dir = savepath +  "/cslip_images/field_" +  f + "/";
	datastore = mm.data().createMultipageTIFFDatastore(full_dir, false, false);
	Coords.Builder coordsBuilder = Coordinates.builder();
	if (!found_last){  // keep z the same if we found it last time
		z_current = starting_z;
		setZPositionQuick(zStageName, z_current);
	}
	label = "";
	n = 0;  // don't think we need it
	while (z_current >= max_z){
		Date date = new Date();
		datestr = dateFormat.format(date);
		log_fieldinfo = "\n" + datestr + " Field: " + f + " ";
		debug.write(log_fieldinfo);
		debug.flush();
		mmc.setState("FW103H Filter Wheel", 0);

		try {
			waitForZnew();  // we set z moving in the previous loop
		} catch (Exception e) {
			print("marzhauser causing serial problems yet again");
		}
		checkXYZWait(stageName, zStageName, x_pos[f],
						y_pos[f], z_current, debug, 10); // check end is correct

		cb = mm.data().getCoordsBuilder().z(0).c(0).p(0).t(0);

		ImageStack stack;
		ImagePlus imgplus;

		writeToFile("E:/acquisition control files/las_control.txt", "3,0.1");
		images = mm.live().snap(false);
		image = images.get(0);
		iProcessor = mm.data().ij().createProcessor(image);
		// mmc.waitForSystem();  // throws an uncaught except apparently if XY stage times out...
		writeToFile("E:/acquisition control files/las_control.txt", "4,0.0");
		
		imgplus = new ImagePlus("coverslip", iProcessor);
		
		// for saving stack (for debugging)
		coordsBuilder = coordsBuilder.p(n);
		tmp = image.copyAtCoords(coordsBuilder.build());
		datastore.putImage(tmp);
		
		// subtract objective scatter etc.
		imcalc = new ImageCalculator();
		// print("subtract image");
		imcalc.run("Subtract", imgplus, bg_imgplus);
		// print("image subtracted");
		
		// do imageJ stuff for prefind
		process_start = System.currentTimeMillis();
		find_output = find_coverslip_z(imgplus, minfind_otsuthresh, false, true);
		time_process = System.currentTimeMillis() - process_start;
		// sc.message("processing time: " + time_process + "ms");
		
		z_relative = find_output[0];
		err = find_output[1];
		// print(err);
		z_real = z_current;
		if (err != 0){
			sc.message("Failed to find coverslip at this z: " + z_current);
			// start the move to save some time
			// little bit of code so that we don't start from lowest z every time - saves time
			if (found_last){  // if we kept z the same and didnt find, start from beginning
				sc.message("Starting again at lowest z after failing to find at same z as previous");
				z_current = starting_z;
				setZPositionNonBlocking(zStageName, z_current);
				n = 0;
				found_last = false;  // so we don't get stuck
			} else if (z_current + step_z >= max_z ){  // don't move if going to be too far
				z_current += step_z;  // next z
				setZPositionNonBlocking(zStageName, z_current);  // done to be a bit faster
			} else {  // z_current + step_z < max_z 
				coverslip_z_positions[f] = (int)starting_z;
				break;  // unecessary, but safe
			}
		} else {
			z_real += z_relative;
			sc.message("Found coverslip at z: " + z_real);
			sc.message("z_relative: " + z_relative);
			sc.message("z_current: " + z_current);
			found = true;
		}
		if (f > 0 && Math.abs(z_real - coverslip_z_positions[f-1]) > 1000){
			sc.message("Probably found second surface! choosing first surface");
			z_real += 1700;  // probably found the second surface instead
		} else {
			coverslip_z_positions[f] = (int)z_real;
		};
		n++;
		if (found) break;  // no more Z
	} //z 
	datastore.freeze();
	datastore.close();
	mp = pl.getPosition(f);
	label = mp.getLabel();
	x = (int) Math.floor(mp.getX()); 
	y = (int) Math.floor(mp.getY());  
	msp = new MultiStagePosition(stageName, x, y, zStageName, coverslip_z_positions[f]);
	// remove the FAILED tag
	if (label.substring(0,7).equals("FAILED-")) label = label.substring(7,label.length());
	if (label.substring(0,11).equals("NO-SPHEROID")) label = label.substring(11,label.length());
	
	if (found) msp.setLabel(label);
	else msp.setLabel("FAILED-"+label);
	pl_cslip.addPosition(msp);

	found_last = found;
	
	// now find the spheroid ----------------------------------------------///
	//---------------------------------------------------------------------///
	
	if (found && find_spheroids) {
		mmc.setState("FW103H Filter Wheel", fw_pos);
		cslip_2_z = coverslip_z_positions[f] - coverslip_thickness;
		z_current_prefind = cslip_2_z;
		setZPositionQuick(zStageName, z_current_prefind);
		z_above_cslip = 0;
		mmc.setExposure(exposure_for_scan);
		spheroid_found = false;
		finfo.pixelDepth = (double)y_scanwidth_um/nimgs;
		
		writeToFile(filedir + "las.txt","" + spheroid_las_amplitude);
		writeToFile(filedir + "exp.txt","" + exposure_for_scan);
		writeToFile(filedir + "las_channel.txt", "" + las_channel);

		// print("trig: " + trg_dist);
		// print("scan dist:" + y_scanwidth_um);
		// print("nimgs: "+ nimgs);
		// setUpStageRetry(port_xy,trg_dist,scan_speed,scan_tries);
		x_com = 0;
		y_com = 0;

		spheroid_found = false;
		
		while (z_above_cslip >= max_dist_from_cslip){  // note inequality, negative vals
			print("Searching for spheroid at "+ z_current_prefind);
			ImageStack stack;
			ImagePlus imgplus;
			x_com = 0;
			y_com = 0;

			// random safety measure, shouldn't be needed but I'm paranoid
			// 500 for allowing highest cslips, but if we find bottom cslip should certainly
			// not be at the top of the FOV (aka 1000)
			if (z_current_prefind < max_z - 500 + max_dist_from_cslip - coverslip_thickness){
				sc.message("Exceeded max Z height! Skipping");
				sc.message("NO SPHEROID FOUND");
				spheroid_z_positions[f] = cslip_2_z;  // min z
				break;
				// throw MMException("Why are you going this high?"); // remember negative
			}
			
			travelToPositionRetry(
				z_current_prefind,x_pos[f],y_pos[f]-(y_scanwidth_um/2),travel_speed,stageName,zStageName,movetimeout_s,debug);
			start_setup = System.currentTimeMillis();
			// setupstage is really slow, find a faster way to set trigger on
			setUpStageRetry(port_xy,trg_dist,scan_speed,scan_tries);  // travel sets the stage speed, have to set it back
			setupstage_time = System.currentTimeMillis() - start_setup;
			// print("setup stage time: " + setupstage_time + "ms");
			bufferstart = System.currentTimeMillis();
			mmc.clearCircularBuffer();
			buffertime = System.currentTimeMillis() - bufferstart;
			// print("buffer time: " + buffertime + "ms");
			sq_start = System.currentTimeMillis();
			mmc.setProperty(cam, "Triggermode","External");  
			mmc.prepareSequenceAcquisition(cam);
			mmc.startSequenceAcquisition(nimgs, 0, true);
			// print("sequence prep: " + (System.currentTimeMillis() - sq_start) + "ms");
			lv_start = System.currentTimeMillis();
			labviewFileAcqStart(filedir);
			// print("setup with labview time: " + (System.currentTimeMillis() - lv_start) + "ms");
			setXYPositionForAcqRetry(stageName, x_pos[f],y_pos[f]+(y_scanwidth_um/2), scan_tries);
			setup_time = System.currentTimeMillis() - start_setup;
			print("setup time: " + setup_time + "ms");
			start_time = System.currentTimeMillis();
			// acquisition loop
			// get the imageplus stack from buffer
			// print("about to acq");
			// imgplus = acqImagesFromBufferImgplus(nimgs, timeout_between_frames, 1);
			imgplus = acqImagesNoTriggerImgplus(nimgs, img_time_intervals);
			// lazy method that worked before to test....

			
			// ImagePlus imgplus new ImagePlus(); //
			labviewFileAcqStop(filedir);
			mmc.stopSequenceAcquisition();
			mmc.setProperty(cam, "Triggermode","Internal");  

			print("stack acquired");
			
			fi = imgplus.getFileInfo();
			fi.pixelDepth = (double)y_scanwidth_um/nimgs;  // for calculating y_com
			imgplus.setFileInfo(fi);  // may not be necessary? might be a reference
			
			z_prefind_savedir = savepath + "/spheroid_images/field_" +  f + "/z_" + z_above_cslip + "/" ;
			if (!z_prefind_savedir.equals("")) new File(z_prefind_savedir).mkdirs();
			
			find_sph_out = find_spheroid_z(imgplus, mip_spheroid_otsuthresh, true, get_xy_com, z_prefind_savedir, min_size);
			
			spheroid_relative_z = find_sph_out[0];
			x_com = find_sph_out[1];
			y_com = find_sph_out[2];
			spheroid_err = find_sph_out[3];  // successful or not
			
			spheroid_z_real = z_current_prefind;
			if (spheroid_err == 0){
				if (z_current_prefind + spheroid_relative_z > cslip_2_z - coverslip_thickness + max_dist_from_cslip){
						spheroid_z_real = z_current_prefind + spheroid_relative_z;
				}	
				sc.message("Spheroid found at " + spheroid_z_real + ", relative position " + spheroid_relative_z);
				spheroid_found = true;
				spheroid_z_positions[f] = spheroid_z_real;
				spheroid_found = true;
				break;
			} else {
				sc.message("Failed to find spheroid at this z: " + z_current_prefind);
				if (z_above_cslip + z_step_spheroid <= max_dist_from_cslip){
					sc.message("NO SPHEROID FOUND");
					spheroid_z_positions[f] = cslip_2_z;  // min z
					break; // for safety not necessary but hey
				}
			}
			z_above_cslip += z_step_spheroid;
			z_current_prefind += z_step_spheroid;
		}
		if (get_xy_com){
			print("x_com: "+ x_com);
			print("y_com " + y_com);
			
			print("x before: "+ x);
			print("y before " + y);
			
			x += x_com;
			y += y_com;

			print("x after: "+ x);
			print("y after " + y);

			spheroid_x_positions[f] = x_com;
			spheroid_y_positions[f] = y_com;
		}
		msp_s = new MultiStagePosition(stageName, x, y, zStageName, spheroid_z_positions[f]);
		print(label);
		if (spheroid_found) msp_s.setLabel(label);
		else msp_s.setLabel("NO-SPHEROID-"+label);
		pl_spheroid.addPosition(msp_s);					
	} //
	else {  // if coverslip part failed (or we don't run spheroid finding)
		msp_s = msp;  // same as cslip one from before
		pl_spheroid.addPosition(msp);
	}

	// Move to the next position/field
	g = f < (n_pos-1) ? f+1 : 0;
	if (g == 0) z_current = starting_z;  // safety
	travelToPositionRetry(
		z_current,x_pos[g],y_pos[g],travel_speed,stageName,zStageName,movetimeout_s,debug);
} // field loop

if (update_z){
	if (find_spheroids) mm.positions().setPositionList(pl_spheroid);
	else mm.positions().setPositionList(pl_cslip);
}
pl_cslip.save(savepath + "coverslips.pos");

time_end = System.currentTimeMillis();
delta_t = Math.max(0,Math.round((time_end - time_begin)/1000)); // seconds
sc.message("Total took " + delta_t + "s");		

// reset filter position
mmc.setState("FW103H Filter Wheel", fw_pos);

// save well names
BufferedWriter wells = new BufferedWriter(new FileWriter(savepath + "position_names.csv"));
BufferedWriter row_col_z = new BufferedWriter(new FileWriter(savepath + "row_col_z.csv"));
BufferedWriter coverslip_z = new BufferedWriter(new FileWriter(savepath + "coverslip_z.csv"));
	
for(n=0; n<n_pos; n++){
	mp = pl.getPosition(n);
	wells.write(""+n+","+mp.label+",\n");
	coverslip_z.write(coverslip_z_positions[n] + "\n");
	row_col_z.write(rows_and_cols[n][0] + "," + rows_and_cols[n][1] +
		"," + coverslip_z_positions[n] + "\n");
}
wells.close();
coverslip_z.close();
row_col_z.close();

if (find_spheroids){
	BufferedWriter row_col_spheroid_z = new BufferedWriter(new FileWriter(savepath + "row_col_spheroid_z.csv"));
	BufferedWriter row_col_spheroid_xyz = new BufferedWriter(new FileWriter(savepath + "row_col_spheroid_xyz.csv"));
	BufferedWriter spheroid_z = new BufferedWriter(new FileWriter(savepath + "spheroid_z.csv"));
	pl_spheroid.save(savepath + "spheroids.pos");
	for(n=0; n<n_pos; n++){
		spheroid_z.write(spheroid_z_positions[n] + "\n");
		row_col_spheroid_z.write(rows_and_cols[n][0] + "," + rows_and_cols[n][1] +
		"," + spheroid_z_positions[n] + "\n");
		
		row_col_spheroid_xyz.write(rows_and_cols[n][0] + "," + rows_and_cols[n][1] +
		"," + spheroid_x_positions[n] + "," + spheroid_y_positions[n] + "," + spheroid_z_positions[n] + "\n");
	}
	row_col_spheroid_z.close();
	row_col_spheroid_xyz.close();
	spheroid_z.close();
}

tot_err = move_well_n_err + setup_n_err + scan_start_n_err + scan_end_n_err;

log.write("\n Ended with " + tot_err + " error(s):\n");
log.write(move_well_n_err + " moving to well error(s)\n");
log.write(setup_n_err + " setting up scan error(s)\n");
log.write(scan_start_n_err + " scan starting error(s)\n");
log.write(scan_end_n_err + " scan end error(s)\n");
log.flush();
log.close();
debug.close();