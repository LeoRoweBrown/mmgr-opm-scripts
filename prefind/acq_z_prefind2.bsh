// Scans in Z to pre-find in Z

import java.util.Date;
import java.text.DateFormat;
import java.text.SimpleDateFormat;
import org.micromanager.data.Datastore;
import org.micromanager.display.DisplayWindow;
import org.micromanager.PositionList;
import org.micromanager.LogManager;
import mmcorej.TaggedImage;
import org.micromanager.data.Image;
import org.micromanager.data.Coords;
import org.micromanager.data.Coordinates;

source("C:/Users/OPMuser/Documents/micromanager/mmgr-opm-scripts/helpers.bsh");

// import org.micromanager.ScriptController;

// since sc.message -> sc.message
// studio class is mm in beanshell scripting:
mmc = mm.getCMMCore();
sc = mm.getScriptController();

// print("In correct file");

// Image while scanning; hardcoded positions for the spheroids
// For FRET timelapse imaging of several fields
// Deleted comments (see in 0.2_one_field)
String zStageName = "ZAxis";
// String zStageName = "ThorZDrive";
String stageName = mmc.getXYStageDevice();
String cam = "pco_camera_bis"; 	
String acq = "acq_rfl"; 	

DateFormat dateFormat = new SimpleDateFormat("yy-MM-dd/HH-mm-ss");
Date date = new Date();

savedir = "E:/zprefindTest/" + dateFormat.format(date) + "/";

//straight_dir = savedir;
//reflect_dir = savedir;
new File(savedir).mkdirs();
new File(savedir).mkdirs();

filedir = "E:/acquisition control files/";

term = "\r";
sc.message("Cleaning up");
/////////////////////////////////////////////////////////////////////
// Clean everything before beginning
cleanup(cam,"",stageName);
sc.message("Successfully cleaned up");
//sc.message("Test");
// User-defined parameters
/////////////////////////////////////////////////////////////////////

// Position paramters
	use_ctr = true;
	// WORK THIS OUT IN REAL UNITS - current Marzhauser doesn't report real units
	dist_from_z_ctr = 1500;
	
	first_field = 0; // 0-indexing
	unset("z_offset");
	z_offset = 0;//-100000;
	y_offset = 0;

// Triggering parameters
	acq_type = 1;
		// Acquisition types: 
		// 0 = Fret
		// 1 = Alternate
		// 2 = Simultaneous

	filter_naming = true;
	max_field_skips = 5;
	max_retries = 3;
	movetimeout_s = 3*60;
	max_dropped_frames = 1;

	trg_dist = 1.4; //micron
	// Positions are in microns, exp. in ms, speed in mm/s = microns/ms. nimg is n. of images.
	double scan_speed = 0.16; // microns/ms

// Saving parameters
	save_type = 1;
		// Saving types: 
		// 0 = save after each run
		// 1 = save after each field
	
/////////////////////////////////////////////////////////////////////
// Filter wheel positions and laser channels

// donor exc and em, donor exc and acceptor em, direct acceptor exc and em.
int[] fw_pos = {2};
// double fw_angle = 60.0; // angle between filter wheel positions
int[] las_channels = {1}; // DAQ channels corresponding to each fw pos
int[] wavelengths = {488, 515, 561, 642};
int[] amplitudes = {5};
int[] exposures  = {10};

/*// donor exc and em, donor exc and acceptor em, direct acceptor exc and em.
int[] fw_pos = {1};
// double fw_angle = 60.0; // angle between filter wheel positions
int[] las_channels = {3}; // DAQ channels corresponding to each fw pos
int[] wavelengths = {488};
int[] amplitudes = {5};
int[] exposures  = {10};*/

if ( fw_pos.length != las_channels.length ){
	throw new MMException("Laser channels array not same length as filter wheel positions array");
}
	
/////////////////////////////////////////////////////////////////////
// Constants

double travel_speed = 10.;

int[] x_lim = {-12000000,1000000};
int[] y_lim = {-12000000,1000000};

inter_dist = 10000; // microns

inter_time = 3000;

/////////////////////////////////////////////////////////////////////	
//writeToFile("E:/acquisition control files/las2.txt", "0.5");
sc.message("Writing files");

writeToFile(filedir + "acqType.txt","" + acq_type);
// writeToFile(filedir + "las2.txt","" + 0);
writeToFile(filedir + "las.txt","" + amplitudes[0]);
writeToFile(filedir + "exp.txt","" + exposures[0]);
// writeToFile(filedir + "exp2.txt","" + 0);
writeToFile(filedir + "run.txt","0");
writeToFile(filedir + "las_channel.txt", "");
writeToFile(filedir + "finished.txt", "0");

/////////////////////////////////////////////////////////////////////
unset("x_pos");
unset("y_pos");
unset("f_end");
unset("f_bg");

int n_fields = posCtrNum();
int[] x_pos = new int[n_fields];
int[] f_bg = new int[n_fields];
int[] f_end= new int[n_fields];
int[] y_pos = new int[n_fields];

int ret = convertCtrZ(f_bg, f_end, x_pos, y_pos, dist_from_z_ctr, dist_from_z_ctr);	

if (n_fields == 0){
	throw new Exception("Empty position list!");
}

// Positions in microns

u1 = checkPos(x_pos, x_lim);
u2 = checkPos(y_pos, y_lim);

if((u1+u2) != 0) {
     throw new MMException("Position errors");
}

unset("n_img");
int[] n_img = new int[n_fields];
java.util.Arrays.fill(n_img, 0);

n_tot_img = 0;
z_spacing = 200;

for(i = 0;i< n_fields;i++) {
	y_pos[i] = y_pos[i] + y_offset;
	f_bg[i] = f_bg[i] + z_offset;
	f_end[i] = f_end[i] + z_offset;
	n_img[i] = (int) Math.ceil((double) (((double) f_end[i]) - ((double) f_bg[i])) / ((double) z_spacing)); 
	n_tot_img = n_tot_img + n_img[i];
};

print("number of images: " + n_img.length);
print("z spacing: " + z_spacing);
// Save parameters

BufferedWriter out = new BufferedWriter(new FileWriter(savedir + "parameters.txt"));     

out.write("exp");
	for(i = 0;i< exposures.length;i++) {
		out.write(" ; " + exposures[i]); 
	}
out.write("\n" + "las");
		for(i = 0;i< amplitudes.length;i++) {
		out.write(" ; " + amplitudes[i]); 
	} 
out.write("\n" + "wavelength");
	for(i = 0;i< wavelengths.length;i++) {
	out.write(" ; " + wavelengths[i]); 
} 
out.write("\n" + "las_channels");
	for(i = 0;i< las_channels.length;i++) {
	out.write(" ; " + las_channels[i]); 
}
out.write("\n" + "fw_pos");
	for(i = 0;i< fw_pos.length;i++) {
	out.write(" ; " + fw_pos[i]); 
} 
out.write("travel_speed ; " + travel_speed + "\n");
out.write("x_pos");
	for(i = 0;i< n_fields;i++) { 	out.write(" ; " + x_pos[i]); }; 
out.write("\n f_bg");
	for(i = 0;i< n_fields;i++) { 	out.write(" ; " + f_bg[i]); };
out.write("\n f_end");
	for(i = 0;i< n_fields;i++) { 	out.write(" ; " + f_end[i]); };
out.write("\n y_pos");
	for(i = 0;i< n_fields;i++) { 	out.write(" ; " + y_pos[i]); };
out.write("\n");

out.close();

///////////////////////////////////////////////////////////////////////////

	mmc.setCameraDevice(cam);
		w = (int) mmc.getImageWidth();
		h = (int) mmc.getImageHeight();
		d = (int) mmc.getBytesPerPixel();
		iD = (int) mmc.getImageBitDepth();
	// mmc.setExposure(exp1);
		
	// mmc.setCameraDevice(cam_str);
	// mmc.setExposure(exp2);

	// Increase focus drive speed, decrease number of microsteps (now done in the device adapter)
	sc.message("Focus");
	setUpFocus();
	sc.message("Focus done");
	mmc.setSerialPortCommand("COM1","!trig 0",term); 
	sc.message("Travel");
	travelToPositionRetry(f_bg[0],x_pos[0],y_pos[0],travel_speed,stageName,zStageName,movetimeout_s);
	
	sc.message("Initializing buffer"); 
	mmc.initializeCircularBuffer();

index = 0;
for(f = 0;f< n_fields;f++) {
	for (w = 0; w < fw_pos.length; w++) { 
		// reset
		Datastore datastore;
	
		Coords.Builder coordsBuilder = Coordinates.builder();
	   
		// set txt files for laser params
		writeToFile(filedir + "las.txt","" + amplitudes[w]);
		writeToFile(filedir + "exp.txt","" + exposures[w]);
		writeToFile(filedir + "fw_pos.txt", "" + fw_pos[w]);
		mmc.setState("FW103H Filter Wheel", fw_pos[w]);
		writeToFile(filedir + "las_channel.txt", "" + las_channels[w]);
		mmc.setExposure(exposures[w]);
		sc.message("Filter position: " + fw_pos[w]);
		chan = las_channels[w];
		
		mmc.clearCircularBuffer();
		end_dir = "run_" + index + "/field_" + f + "/" + wavelengths[chan];
	
		// for repeated excitations
		if (filter_naming) end_dir = end_dir + "/" + fw_pos[w];
		
		//Initialize Acquisition
		System.gc(); // added 161223 HS

		// mmc.setProperty(cam, "Triggermode","Internal");
		mmc.setProperty(cam, "Triggermode","External");
		sc.message("Creating datastore");
		
		datastore = createDatastore(acq, savedir + end_dir);
		
		
		// move back to start position for each channel
		travelToPositionRetry(f_bg[f],x_pos[f],y_pos[f],travel_speed,stageName,zStageName,movetimeout_s);
		f_current = f_bg[f];
		ctr = 0;
		for (z = 0; z < n_img[f]; z++){
			//travelToPositionRetry(f_current,x_pos[f],y_pos[f],travel_speed,stageName,zStageName,movetimeout_s);
			mmc.setPosition(zStageName, f_current);
			List images = mm.live().snap(false);
			Image image = images.get(0);
			
			coordsBuilder = coordsBuilder.p(ctr);

			image = image.copyAtCoords(coordsBuilder.build());
			datastore.putImage(image);
					
			f_current += z_spacing;
			ctr++;
		
		}
	
	}
}